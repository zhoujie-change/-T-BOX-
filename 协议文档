# T-BOX Uplink Protocol Specification (Simplified)

## 1. Scope
This document defines a simplified data uplink protocol used by the T-BOX demo module.

## 2. Frame Structure (UART Sensor â†’ ESP32-C3)

| Byte | Meaning |
|------|----------|
| 0xAA | Frame Header |
| LEN  | Data field length |
| ID   | Sensor type |
| DATA | Payload |
| CRC  | XOR checksum |

CRC = XOR(LEN ^ ID ^ DATA...)

## 3. MQTT JSON Uplink (ESP32-C3 â†’ Server)

Topic:
tbox/data/upload

css
å¤åˆ¶ä»£ç 

Payload Example:
```json
{
  "device_id": "C3-01-AB",
  "timestamp": 1731600000,
  "heartbeat": 1,
  "sensor": {
      "id": 1,
      "value": 32.6
  },
  "status": {
      "vbat": 3.31,
      "signal": -57
  }
}
4. Error Codes
0x01: CRC error

0x02: Frame length mismatch

0x03: Null payload

0x04: Sensor offline

yaml
å¤åˆ¶ä»£ç 

---

# ğŸš€ **ç¬¬å››éƒ¨åˆ†ï¼šç¡¬ä»¶æ–‡æ¡£**

**æ–‡ä»¶ï¼š`hardware/wiring_diagram.md`**

Hardware Wiring for ESP32-C3 T-BOX Demo
1. Power
5V â†’ DC-DC â†’ 3.3V â†’ ESP32-C3 VCC

Add a 10uF + 100nF decoupling capacitor near power pin

2. UART Sensor
Sensor Pin	ESP32-C3 Pin
TX	GPIO20 (RX)
RX	GPIO21 (TX)
GND	GND
VCC	3.3V

3. Debug UART
USB-to-UART â†’ ESP32-C3:

TX â†’ GPIO7

RX â†’ GPIO6

GND â†’ GND

4. EMI/ESD considerations
Add 22Î© series resistor on UART TX for signal integrity

Optional TVS diode on power input

yaml
å¤åˆ¶ä»£ç 

---

# ğŸš€ **ç¬¬äº”éƒ¨åˆ†ï¼šè°ƒè¯•è®°å½•æ¨¡æ¿ï¼ˆéå¸¸åŠ åˆ†ï¼‰**

**æ–‡ä»¶ï¼š`docs/debugging_records.md`**

Debugging Records
[1] UART frame CRC error
Problem: UART frames received but CRC mismatch
Analysis:

Captured waveform via oscilloscope

Observed under-shoot on TX line; possible signal integrity issue

Fix:

Added 22Î© series resistor

CRC error rate dropped to <0.1%

[2] MQTT reconnect loop
Cause: WiFi reconnect timeout shorter than MQTT keepalive
Fix: Adjusted keepalive to 30s; exception resolved

[3] JSON formatting error
Cause: sprintf buffer too small
Fix: Increased buffer size to 256 bytes

yaml
å¤åˆ¶ä»£ç 

---

# ğŸš€ **ç¬¬å…­éƒ¨åˆ†ï¼šESP32-C3 ä»£ç æ¡†æ¶ï¼ˆå¯ç›´æ¥è¿è¡Œï¼‰**

### **1. main.c**

#include "uart_driver.h"
#include "mqtt_upload.h"
#include <stdio.h>

void app_main(void)
{
uart_init();
mqtt_init();

scss
å¤åˆ¶ä»£ç 
while (1) {
    sensor_frame_t frame;

    if (uart_read_frame(&frame)) {
        mqtt_upload(frame);
    }

    vTaskDelay(100 / portTICK_PERIOD_MS);
}
}

yaml
å¤åˆ¶ä»£ç 

---

### **2. uart_driver.c**

#include "uart_driver.h"
#include "driver/uart.h"

#define UART_NUM UART_NUM_1
#define BUF_SIZE 128

void uart_init(void)
{
uart_config_t cfg = {
.baud_rate = 115200,
.data_bits = UART_DATA_8_BITS,
.stop_bits = UART_STOP_BITS_1,
.parity = UART_PARITY_DISABLE
};

scss
å¤åˆ¶ä»£ç 
uart_param_config(UART_NUM, &cfg);
uart_set_pin(UART_NUM, 21, 20, -1, -1);
uart_driver_install(UART_NUM, BUF_SIZE, 0, 0, NULL, 0);
}

int uart_read_frame(sensor_frame_t *out)
{
uint8_t data[BUF_SIZE];
int len = uart_read_bytes(UART_NUM, data, BUF_SIZE, 20);

kotlin
å¤åˆ¶ä»£ç 
if (len < 5 || data[0] != 0xAA)
    return 0;

uint8_t crc = 0;
for (int i = 1; i < len - 1; i++)
    crc ^= data[i];

if (crc != data[len - 1])
    return 0;

out->id    = data[2];
out->value = (float)data[3];
return 1;
}

yaml
å¤åˆ¶ä»£ç 

---

### **3. mqtt_upload.c**

#include "mqtt_upload.h"
#include "cJSON.h"
#include "esp_log.h"

void mqtt_upload(sensor_frame_t frame)
{
cJSON *root = cJSON_CreateObject();
cJSON_AddStringToObject(root, "device_id", "C3-01-AB");
cJSON_AddNumberToObject(root, "timestamp", time(NULL));

pgsql
å¤åˆ¶ä»£ç 
cJSON *sensor = cJSON_CreateObject();
cJSON_AddNumberToObject(sensor, "id", frame.id);
cJSON_AddNumberToObject(sensor, "value", frame.value);
cJSON_AddItemToObject(root, "sensor", sensor);

char *json = cJSON_PrintUnformatted(root);
mqtt_publish("tbox/data/upload", json);

free(json);
cJSON_Delete(root);
}

yaml
å¤åˆ¶ä»£ç 

---
